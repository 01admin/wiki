### 차세대 스마트 컨트랙트와 분산화된 응용 프로그램 플랫폼

Satoshi Nakamoto가 2009년 1월 비트코인 블록체인을 처음 세상에 공개했을 때, 혁신적이면서 시험되지 않은 두 가지 개념을 동시에 제시했다. 첫번째는 어떠한 뒷받침도, 내재 가치([intrinsic value](http://bitcoinmagazine.com/8640/an-exploration-of-intrinsic-value-what-it-is-why-bitcoin-doesnt-have-it-and-why-bitcoin-does-have-it/))도, 중앙발행자도 없이 가치를 유지하는 분산화된 P2P 온라인 통화(decentralized peer-to-peer online currency)로서의 비트코인이다. 지금까지 통화로서의 비트코인은 중앙 은행이 없는 화폐라는 정치적 관점과 큰 가격변동성 관점에서 사람들의 주목을 받아 왔다. 그러나 비트코인에는 Satoshi의 중대한 실험 - 작업증명(proof of work) 기반 블록체인에 의해 트랜잭션의 순서를 공공이(public) 합의한다는 또 다른 중요한 측면이 있다. 이러한 응용 프로그램으로서의 비트코인은 first-to-file시스템으로 설명할 수 있다. 예를 들어 만약 50BTC를 보유하고 있는 하나의 주체가 같은 50BTC를 A와 B로 동시에 보냈을 때 처음에 컨펌된(confirmed) 트랜잭션만 실행된다. 비트코인이 등장하기 이전에는 두 트랜잭션 중 어느 쪽이 먼저 이루어졌는지를 결정하는 본질적인 방법이 없었고, 이는 분산 디지털 통화의 발전을 방해했다. Satoshi의 블록체인은 이 문제를 최초로 신뢰할 수 있는 방법으로 해결했다. 요즘들어 사람들은 비트코인의 이러한 두번째 특징에 기반해서, 블록체인의 개념을 단순한 돈 이상의 것에 어떻게 적용할 수 있는가에 대해 주목하기 시작했다.

블록체인에 디지털 자산을 탑재하는 사례로는 사용자정의 화폐(custom currency) 또는 사용자정의 금융상품을 기록하거나(["colored coins"](https://docs.google.com/a/buterin.com/document/d/1AnkP_cVZTCMLIzw4DvsW6M8Q2JC0lIzrTLuoWu2z1BE/edit)), 물리적 장치의 소유권을 기록하거나(["smart property"](htups://en.bitcoin.it/wiki/Smart_Property)), 도메인 네임 같은 대체 불가능한 자산(non-fungible asset)을 기록하는 것("Namecoin")등이 있다. 더 발전된 응용 프로그램으로서 분산화된 환전, 분산화된 금융 파생상품, p2p 도박, 분산화된 신분보관 및 평판시스템 등이 있다. 이와 더불어 또 다른 중요한 연구 분야는 "smart contract" - 사전에 정해진 규칙에 따라 디지털 자산을 자동으로 이동시는 시스템이다. 가령, 다음과 같은 재무계약을 한다고 하자. "A는 하루에 화폐를 X만큼 인출할 수 있고, B는 하루에 Y까지 통화를 인출할 수 있다. A와 B가 함께라면 얼마든지 인출할 수 있다. 그리고 A는 B가 인출할 권리를 정지시킬 수 있다". 이 계약의 논리적인 확장이 분산된 자동화 조직([decentralized autonomous organizations](http://bitcoinmagazine.com/7050/bootstrapping-a-decentralized-autonomous-corporation-part-i/) (DAOs)) -  조직의 내부규칙이 프로그램 코딩되어 조직의 전체 자산을 자동으로 통제하는 장기적인 smart contract이다. Ethereum이 제공하려는 것은 완벽한 튜링완전(turing-complete) 프로그래밍 언어가 심어진 블록체인이다. 이 프로그래밍 언어는, 코딩된 규칙에 따라 '어떤 상태'를 다르게 변화시키는 기능(arbitrary state transition functions)이 포함된 "계약(contracts)"을 유저들이 작성할 수 있게 함으로써 앞서 설명한 시스템 구현을 가능하게 한다. 이 뿐만 아니라 우리가 아직 상상하지 못한 다른 많은 것들도 할 수 있다.

### Table of Contents

* [역사](#역사)
    * [상태전이시스템으로서의 비트코인](#상태전이시스템으로서의-비트코인)
    * [채굴](#채굴)
    * [Merkle Trees]
    * [Alternative Blockchain Applications]
    * [Scripting]
* [Ethereum]
    * [Ethereum Accounts]
    * [Messages and Transactions]
    * [Ethereum State Transition Function]
    * [Code Execution]
    * [Blockchain and Mining]
* [Applications]
    * [Token Systems]
    * [Financial derivatives]
    * [Identity and Reputation Systems]
    * [Decentralized File Storage]
    * [Decentralized Autonomous Organizations]
    * [Further Applications]
* [Miscellanea And Concerns]
    * [Modified GHOST Implementation]
    * [Fees]
    * [Computation And Turing-Completeness]
    * [Currency And Issuance]
    * [Mining Centralization]
    * [Scalability]
* [Conclusion]
* [References and Further Reading]

## 비트코인과 기존 개념들에 대한 소개

### 역사

분산화된 디지털 통화의 개념은, 재산등록 같은 어플리케이션과 마찬가지로 지난 수십년간 우리 주변에 있었다. 1980~90년대의 익명 e-cash 프로토콜은 주로 Chaumian blinding로 알려진 암호 프리미티브(cryptographic primitive)에 기반하였고 개인정보를 강력하게 보호하는 통화를 제공하였으나 중앙집권적인 중개인에 의존했기 때문에 견인력을 얻는데 실패했다. 1998년 Wei Dai의 [b-money](http://www.weidai.com/bmoney.txt)는 분산합의 뿐만 아니라 계산 퍼즐을 풀게 함으로서 돈을 만드는 아이디어를 최초로 제안하였지만 분산합의를 실제로 어떻게 구현할지에 대한 자세한 방법을 제시하지 못했다. 2005년에 Hall Finney는 "재사용 가능한 작업증명([reusable proofs of work](http://www.finney.org/~hal/rpow/))" 개념을 소개하였다. 이 시스템은 b-money의 아이디어에 Adam Back의 계산 난이도 해시캐시 퍼즐(computationally difficult Hashcash puzzles)을 조합한 것이었다. 그러나 이 과정의 마지막(backend)에 신뢰해야 하는 컴퓨팅(trusted computing)을 두고 그것에 의존함으로써, 이상을 구현하는데 또 다시 실패했다.

통화는 트랜잭션의 순서가 매우 중요한 first-to-file 애플리케이션이기 때문에 분산 통화는 분산화된 순서합의 방법이 반드시 필요하다. 복수집단 사이의 합의에 필요한 비잔티움 장애 허용(Byzantine-fault-tolerant)을 안전하게 구현하기 위한 많은 연구가 오랫동안 진행돼 왔지만, 비트코인 이전의 모든 프로토콜은 이 문제의 절반밖에 해결하지 못한 것이 사실이다. 기존 프로토콜들은 시스템에 참여하는 모든 참가자가 알려져 있다고 가정하고 예를 들어 "만약 N개의 집단(노드)이 참여하면 악의적인 행위자 수가 N/4가 될 때까지는 시스템이 견딜 수 있다"라는 형태로 보안마진을 결정했다. 그러나 문제는 가정을 바꿔서 참가자들을 익명이라 하면, 그러한 보안마진은 sybil attack - 어떤 하나의 공격자가 수천개의 가상 노드를 서버에 만들거나 봇넷을 생성하고 이 노드들을 이용해서 대다수 점유율을 강제로 얻어내는 공격 - 에 의해 취약해질 수 있다는 것이다. 

Satoshi의 혁신은 매우 단순한 분산화된 합의 프로토콜과 작업증명(proof of work)을 결합한 것이다. 분산합의 프로토콜의 기반이 되는 비트코인의 노드들은, 트랜잭션을 매 10분마다 블록에 기록하고 이 블록을 이전블록에 연결하여 계속 성장하는 블록체인을 생성한다. 그리고 노드들은 Proof of work에 의해 이와 같이 관여할 수 있는 권리를 획득한다. 물론 거대한 계산 파워를 가진 노드는 큰 영향력을 가지게 되지만, 네트워크로 연결된 전체 노드들의 계산 능력을 몇몇 노드가 따라잡는 것은 백만 노드를 시뮬레이션 하는 것보다 훨씬 어렵다. 이처럼 비트코인 블록체인 모델은 단순하지만, 그럼에도 불구하고 충분히 훌륭하다는 것이 증명되어 왔다. 그리고 이 모델은 탄생이후 5년이 넘도록 전 세계 200가지가 넘는 통화 및 프로토콜들의 기초가 되었다.

### 상태전이시스템으로서의 비트코인

![statetransition.png](http://vitalik.ca/files/statetransition.png?2)

비트코인 장부를 기술적인 관점에서 봤을 때, 발행된 모든 비트코인의 소유권 현황으로 이루어진 "상태(state, S)", 현재 상태 정보를 얻고 트랜잭션(transaction, TX)을 실행하여 새로운 상태(S')를 출력하는 "상태전이함수(state transition function)"로 구성된 상태전이시스템(state transition system)으로 생각할 수 있다. 표준 은행 시스템에 비유하자면 상태는 계좌잔고표(balance sheet)이고 트랜잭션은 A에서 B로 $X를 송금하라는 요청이며, 상태전이함수에 의해 A의 계좌에서는 $X가 감소하고 B의 계좌에서는 $X가 증가한다. 만약 처음에 A의 계좌에 있는 금액이 $X 이하인 경우에는 상태전이함수가 에러를 리턴한다.
이러한 상태전이를 비트코인 장부에서는 다음과 같이 정의할 수 있다.

    APPLY(S,TX) -> S' or ERROR

은행 시스템 예시에서는 다음과 같다.

    APPLY({ Alice: $50, Bob: $50 },"send $20 from Alice to Bob") = { Alice: $30, Bob: $70 }

    APPLY({ Alice: $50, Bob: $50 },"send $70 from Alice to Bob") = ERROR

비트코인에서 "상태(state)"는 그 지갑에서 아직 사용되지 않은 모든 코인덩어리들(기술적으로 표현하면 소비되지 않은 이전트랜잭션출력, UTXO(Unspent Transaction Outputs))의 집합이다. 각 UTXO들에는 각자의 코인금액이 표시되어 있고 이 UTXO의 소유자(20byte의 주소로 정의되는 암호화된 공개키(public key))정보가 들어 있다. 트랜잭션에는 하나 이상의 입력(inputs) 및 출력이 포함된다. 각 입력에는 보내는 쪽 지갑주소에서 선택된 UTXO에 대한 참조정보와, 해당지갑주소에 대응되는 개인키(private key)가 생성한 암호화된 서명을 담고 있다. 그리고 각 출력들은 상태에 추가될 새로운 UTXO 정보를 가지고 있다.

상태전이함수 `APPLY(S,TX) -> S'` 는 대강 다음과 같이 정의할 수 있다.

1. TX의 각 입력에 대해 :
    * 만약 참조된 UTXO가 `S`에 없다면, 에러를 리턴.
    * 만약 서명이 UTXO의 소유자와 매치되지 않으면, 에러를 리턴.
2. 만약 입력에 사용된 UTXO들 금액의 합이 출력 UTXO들 금액의 합보다 작으면, 에러를 리턴.
3. 입력에 사용된 UTXO가 삭제되고 출력 UTXO가 추가된 `S`를 리턴.

여기서 1번의 첫번째 과정은 존재하지 않는 코인이 트랜잭션에 사용되는 것을 막기 위한 것이고 1번의 두번째 과정은 다른 사람의 코인이 트랜잭션에 사용되는 것을 막기 위한 것이다. 위 절차를 실제 비트코인 지불과정에 적용하면 다음과 같다. Alice가 Bob에게 11.7 BTC를 보내고 싶다고 가정하자. 먼저 Alice 지갑주소로부터 표시된 금액의 합이 적어도 11.7 BTC 이상인 UTXO의 집합을 찾는다. 실제 대부분의 경우에는 11.7 BTC를 정확히 바로 선택할 수 없다. Alice의 지갑주소에서 각각 6, 4, 2 BTC 가 표시된 3개의 UTXO를 참조할 수 있다고 하자. 이 3개의 UTXO가 트랜잭션의 input이 되고 2개의 output이 생성된다. Output 중 하나는 11.7 BTC가 표시된 새로운 UTXO이며 소유자는 Bob의 지갑주소가 된다. 그리고 다른 하나는 12(6+4+2) - 11.7 = 0.3 BTC의 "잔돈(change)"이 표시된 새로운 UTXO이며 소유자는 Alice 자신의 지갑주소가 된다.

### 채굴

![block_picture.jpg](http://vitalik.ca/files/block_picture.png)

만약 신뢰할 수 있는 중앙집권화된 서비스로서 접근한다면 이 시스템은 위에서 서술된 상태전이시스템을 엄밀하게 코딩함으로써 간단하게 구현할 수 있을 것이다. 그러나 비트코인으로 분산 통화 시스템을 구축하기 위해서는 모든 사람이 수긍할 수 있는 트랜잭션 순서 합의 시스템이 상태전이시스템에 조합되어야 한다. 비트코인의 분산 합의 과정은 네트워크에 노드들을 필요로 하며 이 노드들은 "블록(blocks)"이라 불리는 트랜잭션 패키지를 연속적으로 생성한다. 이 네트워크는 약 10분마다 하나의 블록을 생성하도록 계획되어 있고 각 블록은 타임스탬프, nonce, 이전 블록에 대한 참조(이전 블록의 해시), 그리고 이전 블록 이후에 발생한 모든 트랜잭션의 목록을 포함한다. 이 과정을 통해서 지속적으로 성장하는 블록체인 - 비트코인 장부의 최신 상태(state)를 나타내기 위한 업데이트 - 를 생성한다.

이 체계에서 나타난 블록이 유효한지 아닌지를 확인하기 위한 알고리즘은 다음과 같다.

1. 생성되는 블록에 의해 참조되는 이전 블록이 존재하는지, 유효한지 확인한다.
2. 생성되는 블록의 타임스탬프 값이 이전 블록의 타임스탬프 값보다 크면서 2시간 이내인지 확인한다.
3. 생성되는 블록의 작업증명(proof of work)이 유효한지 확인한다.
4. `S[0]`를 이전 블록의 마지막 상태(state)가 되도록 설정한다.
5. `TX`를 `n`개의 트랜잭션을 가지는, 생성되는 블록의 트랜잭션 목록으로 가정한다. 폐구간 `0...n-1`의 모든 i에 대해, `S[i+1] = APPLY(S[i], TX[i])`집합 중 어느 하나라도 에러를 리턴하면 거짓(false)를 리턴하며 종료한다.
6. 참(true)를 리턴하고, `S[n]`를 지금 생성된 블럭의 마지막 상태로 등록한다. 

기본적으로 블록의 각 트랜잭션은 유효한 상태전이를 일으킨다. 어떤 방법으로도 블록 내에 상태가 직접 코딩되지 않는 것에 주목해보자. 상태는 직접 저장되지는 않지만 유효한 노드를 통해 다시 불러올 수 있는 추상적인 개념으로, 어떤 블록일지라도 기원상태(genesis state)부터 해당 블록까지의 모든 트랜잭션을 순차적으로 적용함으로써 이 블록의 상태를 계산해낼 수 있다. 채굴자가 블록에 포함시키는 트랜잭션의 순서에 주목해보자. 만약 어떤 블록에 A와 B라는 두 트랜잭션이 있고 B가 A의 출력 UTXO를 소비한다고 하자. 이때 A가 B이전의 트랜잭션인 경우 그 블록은 유효하지만 그렇지 않으면 유효하지 않다.

블록 유효성 검증 알고리즘에서 흥미로운 부분은 "작업증명(proof of work)" 개념:모든 블록 각각의 SHA256 해시가, 동적으로 조정되는 목표값(ethereum 영문 백서를 작성하는 시점에서 대략 2<sup>192</sup>) 보다 작아야 된다는 조건이다. 작업증명의 목적은 블록 생성을 계산적으로 어렵게 만들어서 sybil 공격자들이 원하는대로 전체 블록체인을 고치는 것을 방지하는 것이다. SHA256은 전혀 예측불가능한 유사난수 함수(pseudorandom function)로 설계되었기 때문에 유효 블록을 생성하기 위한 유일한 방법은 블록헤더의 nonce 값을 계속해서 증가시키면서 새로운 해시가 위의 조건을 만족하는지 확인하는 과정을 반복하는 것이다. 현재 목표값인 2<sup>192</sup>는 평균적으로 2<sup>64</sup>번의 시도가 필요함을 의미한다. 일반적으로 이 목표값은 매 2016개의 블록마다 네트워크에 의해 재보정되어서 네트워크의 현재 노드에 의해 평균적으로 10분마다 새로운 블록이 생성되도록 변경된다. 이러한 연산작업에 대한 보상으로, 현재시점에서 각 블록의 채굴자들은 25 BTC를 획득할 자격을 가진다. 그리고 출력금액보다 입력금액이 큰 트랜잭션이 있다면 그 차액을 "트랜잭션 수수료(transaction fee)"로 얻는다. 이것이 BTC가 발행되는 유일한 방법이며 채굴을 통해서가 아니라 사토시가 만들어낸 최초 블럭의 상태 - 기원상태(genesis state)에도 아무런 코인이 포함되지 않았다.

채굴 목적을 더 잘 이해하기 위해서 악의적인 공격자가 있을 때 어떤 일이 발생하는지 알아보자. 비트코인 기저의 암호는 안전한 것으로 알려져 있다. 그러므로 공격자는 비트코인 시스템에서 암호에 의해 직접 보호되지 않는 부분인 트랜잭션 순서를 공격 목표로 잡을 것이다. 공격자의 전략은 매우 단순하다.

1. 어떤 상품(가급적이면 바로 전달되는 디지털 상품)을 구매하기 위해 판매자에게 100 BTC를 지불한다.
2. 상품이 전송되기를 기다린다.
3. 판매자에게 지불한 것과 같은 100 BTC를 공격자 자신에게 보내는 트랜잭션을 생성한다.(이중지불 시도)
4. 비트코인 네트워크가, 공격자 자신에게 보내는 트랜잭션이 판매자에게 지불하는 트랜잭션보다 먼저 수행된 것으로 인식하도록 한다.

1번이 과정이 발생하고 몇 분 후에 몇몇 채굴자가 그 트랜잭션을 블록에 포함할 것이다. 이 블록 번호를 270000이라 하자. 대략 1시간 후에는 이 블록 다음의 체인에 5개의 블록들이 추가될 것이다. 이 5개의 블록들은 위 1번 트랜잭션을 간접적으로 가리킴으로써 "컨펌(confirming)"한다. 이 시점에서 판매자는 지불이 완료된 것으로 받아들이고 상품을 전송할 것이다. 디지털 상품으로 가정했으므로 전송은 바로 끝난다. 이제 공격자는 판매자에게 보낸 것과 동일한 100 BTC를 공격자 자신에게 보내는 다른 트랜잭션을 생성한다. 만약 공격자가 그냥 단순하게 시도한다면, 채굴자들이 `APPLY(S,TX)`를 실행하고 이 `TX`는 상태에 더 이상 존재하지 않는 UTXO를 소비하려 한다는 것을 알아차리므로 이 트랜잭션은 진행되지 않는다. 그러므로 이 대신에, 같은 부모 블록 269999을 가리키지만 판매자에게 보낸 것을 대체하는 새로운 트랜잭션이 포함된 다른 버전의 블록 270000을 채굴함으로서 블록체인 "분기점(fork)"을 생성한다. 블록 정보가 다르기 때문에 proof of work 가 다시 수행돼야 한다. 그리고 공격자의 새버전 블록 270000은 기존 270000과 다른 해시를 가지므로 원래 블록 270001부터 270005는 공격자의 블록을 가리키지 않는다. 그러므로 원래 체인과 공격자의 새로운 체인은 완벽하게 분리된다. 이러한 분기점에서 비트코인 네트워크의 규칙은 가장 긴 블록체인을 참으로 인식하는 것이다. 공격자가 자신의 체인에서 혼자 작업을 하는 동안 정당한 채굴자들은 원래의 270005체인에서 작업할 것이기 때문에 공격자 자신의 체인을 가장 길게 만들기 위해서는 네트워크의 다른 노드들의 계산능력 조합보다 큰 계산능력을 가져야 한다.(이를 51% attack이라 한다.)

in progress..