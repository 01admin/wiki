### Una Piattaforma di Nuova Generazione per i Contratti Intelligenti e le Applicazioni Decentralizzate

Quando Satoshi Nakamoto attivò per primo, nel Gennaio 2009, la blockchain del Bitcoin, stava introducendo due concetti radicali e altamente non testati fino ad allora. Il primo è il "bitcoin", una moneta online peer-to-peer decentralizzata che mantiene un valore senza nessun supporto, [valore intrinseco](http://bitcoinmagazine.com/8640/an-exploration-of-intrinsic-value-what-it-is-why-bitcoin-doesnt-have-it-and-why-bitcoin-does-have-it/) o emittente centrale. Finora, il "Bitcoin" come unità monetaria ha catturato la maggior parte dell'attenzione del pubblico, sia in termini di aspetti politici di una moneta senza una banca centrale che per l' estrema volatilità del prezzo verso l'alto e verso il basso. Comunque c'è anche un'altra, ugualmente importante, parte del grandioso esperimento di Satoshi: il concetto di una blockchain basata sul  proof-of-work che permette un consenso pubblico sul sistema delle transazioni. Il Bitcoin come un'applicazione può essere descritto come un sistema first-to-file: se un'entità ha 50 BTC, e simultaneamente invia gli stessi 50 BTC ad A e a B, solamente la transazione che viene confermata per prima sarà processata. Non c'è nessun intrinseco modo di determinare quale delle due transazioni è avvenuta prima, e per decenni questo ha ostacolato lo sviluppo delle monete digitali decentralizzate. La blockchain di Satoshi era la prima soluzione decentralizzata. Ed ora, l'attenzione sta iniziando rapidamente a spostarsi verso questa seconda parte della tecnologia Bitcoin, e come il concetto di blockchain possa essere utilizzato per qualcosa di più che il denaro.

Le Applicazioni generalmente citate includono l'utilizzo di risorse digitali sulla blockchain per rappresentare valute personalizzate e strumenti finanziari (["monete colorate"](https://docs.google.com/a/buterin.com/document/d/1AnkP_cVZTCMLIzw4DvsW6M8Q2JC0lIzrTLuoWu2z1BE/edit)), la proprietà di un dispositivo fisico sottostante (["proprietà intelligente"](htups://en.bitcoin.it/wiki/Smart_Property)), assets non fungibili, quali nomi di dominio ("Namecoin") così come le più avanzate applicazioni tipo un exchange decentrallizzato, derivati finanziari, il gioco d'azzardo peer-to-peer ed il sistema di identità e di reputazione sulla blockchain. Un'altra importante area di indagine sono i "contratti intelligenti" - sistemi che automaticamente trasferiscono assets digitali in accordo con regole pre-specificate. Per esempio, si potrebbe avere un contratto di tesoreria nella forma "A può trasferire a X alcune unità di moneta al giorno, B può trasferire a Y alcune unità di moneta al giorno, A e B insieme non possono trasferire niente, ed A può precludere l' "abilità di trasferire" di B. La logica estensione di questo è [organizzazioni autonome decentralizzate](http://bitcoinmagazine.com/7050/bootstrapping-a-decentralized-autonomous-corporation-part-i/) (DAOs) - contratti intelligenti a lungo termine che gestiscono assets e codificano lo statuto di un'intera organizzazione. Quello che Ethereum intende garantire è una blockchain con una linguaggio di programmazione di Turing, completo e costruito al suo interno, che può essere usato per creare "contratti" e per codificare le funzioni arbitrarie di transizione, permettendo agli utenti di creare uno dei sistemi sopra descritti, così come molti altri che non abbiamo ancora immaginato, semplicemente scrivendo la logica in poche righe di codice.

### Tavola dei Contenuti

* [Storia](#history)
    * [Bitcoin come un Sitema di Transizione di Stato](#bitcoin-as-a-state-transition-system)
    * [Mining](#mining)
    * [Merkle Trees](#merkle-trees)
    * [Applicazioni Alternative della blockchain](#alternative-blockchain-applications)
    * [Scripting](#scripting)
* [Ethereum](#ethereum)
    * [Portafogli Ethereum](#ethereum-accounts)
    * [Messaggi e Transazioni](#messages-and-transactions)
    * [Ethereum come un Sitema di Transizione di Stato](#ethereum-state-transition-function)
    * [Esecuzione del Codice](#code-execution)
    * [Blockchain e Mining](#blockchain-and-mining)
* [Applicazioni](#applications)
    * [Sistemi di Prova](#token-systems)
    * [Derivati Finanziari](#financial-derivatives-and-stable-value-currencies)
    * [Sistema di Identità e Reputazione](#identity-and-reputation-systems)
    * [Storage Decentralizzata dei File](#decentralized-file-storage)
    * [Organizzazioni Decentralizzate Autonome](#decentralized-autonomous-organizations)
    * [Ulteriori Applicazioni](#further-applications)
* [Miscellanea e Relazioni](#miscellanea-and-concerns)
    * [Implementazione GHOST Modificata](#modified-ghost-implementation)
    * [Commissioni](#fees)
    * [Calcolo e Completezza di Turing](#computation-and-turing-completeness)
    * [Moneta ed Emissione](#currency-and-issuance)
    * [Centralizzazione del Mining](#mining-centralization)
    * [Scalabilità](#scalability)
* [Conclusione](#conclusion)
* [Referenze ed Ulteriori Letture](#references-and-further-reading)

## Introduzione al Bitcoin ed ai Concetti Esistenti

### Storia

Da decenni sta circolando l'idea di una moneta digitale decentralizzata, così come delle applicazioni alternative come i registri di proprietà. I protocolli anonimi di moneta digitale degli anni '80 e degli anni '90, dipendenti soprattutto su una crittografia primitiva conosciuta come Chaumian blinding, furono forniti da una moneta con un alto tasso di privacy, tuttavia i suddetti protocolli fallirono principalmente per non essere riusciti a guadagnare terreno a causa della loro dipendenza da un intermediario centralizzato. Nel 1998, Wei Dai's [b-money](http://www.weidai.com/bmoney.txt) divenne il primo progetto per l'introduzione dell'idea di creare moneta attraverso la soluzione di puzzle computazionali così come il consenso decentralizzato, ma il progetto era scarno di dettagli su come questo consenso decentralizzato potesse essere concretamente attualizzato. Nel 2005, Hal Finney introdusse il concetto del "[proofs of work riutilizzabile](http://www.finney.org/~hal/rpow/)", un sistema che utilizza le idee provenienti dalla b-moneta insieme ai puzzle computazionali Hashcash di Adam Back per creare un concetto di criptomoneta, ma ancora una volta non riuscii ad ottenere l'idea perché si basava su un calcolo computazionale garantito come backend.

Poichè la moneta è un'applicazione first-to-file, dove l'ordine delle transazioni è spesso di cruciale importanza, monete decentralizzate richiedono una soluzione al consenso decentralizzato. L'ostacolo principale che tutti i protocolli di valuta pre-Bitcoin hanno affrontato consiste nel fatto che, mentre c'era stata moltissima ricerca, per molti anni, sulla creazione di un consenso Byzantine-fault-tolerant condiviso da più parti, dove tutti i protocolli descritti in precedenza risolvevano soltanto la metà del problema. I protocolli supponevano che nel sistema fosse conosciuto, e prodotto margini di sicurezza della forma "se N parti partecipano, poi il sistema può tollerare fino a  N/4 cattivi attori". Tuttavia il problema è che in una regolazione anonima i margini di sicurezza sono vulnerabili da attacchi sibilla, dove un singolo attaccante può creare migliaia di nodi simulati su un server o su una botnet ed usare questi nodi per assicurarsi una quota di maggioranza.

L'innovazione fornita da Satoshi è l'idea di riuscire a combinare un protocollo molto semplice di consenso decentralizzato, basato su dei nodi su cui avvengono le transazioni, che creano una sempre più crescente blockchain attraverso la creazione di "blocchi" ogni 10 minuti, con il proof of work come meccanimso attraverso cui i nodi guadagnano il diritto di partecipare al sistema. Mentre i nodi con una grande quantità di potenza di calcolo hanno proporzionalmente maggiore influenza, raggiungere più potenza computazionale rispetto l'intero network è più difficile rispetto al simulare milioni di nodi. Nonostante la crudezza e la semplicità del modello blockchain del Bitcoin, esso ha dimostrato di essere abbastanza valido, e nel corso dei successivi cinque anni sarebbe diventato il fondamento di oltre duecento monete e protocolli di tutto il mondo.

### Il Bitcoin come un Sistema di Transizione di Stato

![statetransition.png](http://vitalik.ca/files/statetransition.png?2)

Da un punto di vista tecnico, il libro mastro del Bitcoin può essere pensato come un sistema di transizione di stato, dove c'è uno "stato" consistente nella proprietà dello status di tutti i bitcoins esistenti e "la funzione di transizione di stato" che riceve uno stato ed una transizione e trasmette un nuovo stato che ne costituisce il risultato. Nel sistema bancario tradizionale, per esempio, lo stato è il documento costituente il saldo, una transazione è una richiesta di movimentare $X da A a B, e la funzione di transizione di stato sottrae un valore nel conto corrente di A equivalente $X ed incrementa il valore di $X nel conto corrente bancario di B. Se nel conto corrente di A ci sono meno che $X nel primo posto, la funzione di transizione di stato segnala un errore. Quindi, si può formalmente definire:

    APPLY(S,TX) -> S' or ERROR

Nel sistema bancario definito in precedenza:

    APPLY({ Alice: $50, Bob: $50 },"send $20 from Alice to Bob") = { Alice: $30, Bob: $70 }

Ma:
    
    APPLY({ Alice: $50, Bob: $50 },"send $70 from Alice to Bob") = ERROR

Lo "stato" nel Bitcoin è la raccolta di tutte le monete (tecnicamente, "transazioni in uscita non spese" oUTXO) che sono state effettuate ma non ancora spese, con ogni UTXO che ha una denomoninazione ed un proprietario (definito da un indirizzo da 20-byte che è essenzialmente una chiave crittografica pubblica<sup>[1]</sup>). Una transazione contiene uno o più inputs, con ogni input che contiente un riferimento ad un UTXO esistente ed una firma crittografica prodotta da una chiave privata associata all'indirizzo del proprietario, ed uno o più outputs, con ogni outpout contenente un nuovo UTXO che deve essere aggiunto allo stato.

1. Per ogni input in `TX`:
    * Se il riferimento UTXO non è in `S`, si ha un errore.
    * Se la firma provvista non combacia con il proprietario del UTXO, si ha un errore.
2. Se la somma dei valori di tutti gli input UTXO è inferiore alla somma dei valori di tutti gli outpout UTXO, si ha un errore.
3. Si ha `S` con tutti gli input UTXO meno tutti gli outpout UTXO aggiunti.

La prima metà del primo step previene che ai mittenti delle transazioni di spendere monete che non esistono, la seconda metà del primo step previene ai mittenti delle transazioni di spendere monete di altre persone, ed il secondo step fa rispettare la conservazione del valore. Al fine di utilizzare questo per il pagamento, il protocollo è il seguente. Supponiamo che Alice vuole inviare 11.7 BTC a Bob. Per primo, Alice guarderà per un set di UTXO che lei possiede che ammonta fino ad almeno 11.7 BTC. Realisticamente, Alice non sarà in grado di ottenere esattamente 11.7 BTC; si può dire che il valore più piccolo che può ottenere è 6+4+2=12. Lei poi crea una transazione con quei tre inputs ed i due outputs. Il primo output sarà 11.7 BTC con l'indirizzo che appartiene a Bob, ed il secondo output sarà il rimanente 0.3 BTC "scambiato", con il proprietario essendo Alice stessa.

### Mining

![block_picture.jpg](http://vitalik.ca/files/block_picture.png)

Se abbiamo avuto accesso a un servizio centralizzato di fiducia, questo sistema potrebbe essere banale da implementare; esso potrebbe essere codificato esattamente come descritto. Tuttavia, con i Bitcoin noi abbiamo provato a costruire un sistema monetario, così noi avremo bisogno di combinare il sistema di transizione di stato con un sistema di consenso al fine di assicurare che ognuno è d'accordo sull'ordine delle transazioni. Il processo di consenso decentralizzato del Bitcoin richiede nodi nel network che continuamente tetentano di produrre pacchetti di transazioni chiamati "blocchi". Il network è destinato a produrre all'incirca un blocco ogni dieci minuti, con ogni blocco che contiene una marca temporale, un numero, un riferimento a (ad esempio l'hash del) precedente blocco e una lista di tutte le transazione che sono avvenute dal precedente blocco. Con il passare del tempo, questo crea una persistente, sempre crescente, "blockchain" che si aggiorna costantemente per rappresentare l'ultimo stato del libro mastro del Bitcoin.

L'algoritmo per controllare la validità di un blocco, espresso in questo paradigma, è il seguente:

1. Controllo se il blocco precedente esiste ed è valido.
2. Controllo se la marca temporale del blocco è più grande del blocco precedente<sup>[2]</sup> ed è inferiore di 2 ore nel futuro.
3. Controllo se il proof of work sul blocco è valido.
4. Sia `S[0]` lo stato alla fine del blocco precedente.
5. Si supponga `TX` la lista della transazione del blocco con `n` transazioni. Per tutti `i` in `0...n-1`, sia impostato `S[i+1] = APPLY(S[i],TX[i])` Se da qualsiasi applicazione risulti un errore, esce e ritorna falso.
6. Ritorna vero, e registra `S[n]` come uno stato alla fine del blocco.

Essenzialmente, ogni transazione del blocco deve fornire uno transazione di stato che sia valida. Sia abbia nota che ogni stato non è codificato nel blocco in qualsia modo; esso è puramente una astrazione da ricordare per la validazione del nodo e può essere solo essere (in modo sicuro) computata per qualsiasi nodo iniziando dallo stato di genesi e applicata sequenzialmente ad ogni transazione in ogni nodo. Si abbia nota che è importante l'ordine nel quale ogni miner include le transazioni nel blocco; se ci sono due transazioni A e B nel blocco tale che B impiega una UTXO creata da A, poi il blocco sarà validato se A viene prima di  B ma non viceversa.

La parte interessante dell'algoritmo di validazione del blocco è il concetto di "proof of work": la premessa è che l'hash SHA256 di ogni blocco, costituito come un numero di 256-bit, deve essere inferiore di un target regolato dinamicamente, che è al tempo di questo scritto approssimativamente 2<sup>192</sup>. Lo scopo di questo è di rendere computazionalmente "difficile" la creazione di un blocco, prevenendo con ciò agli attacchi sibilla dal ricreare l'intera blockchain a loro favore. Poichè SHA256 è progettato per essere una funzione completamente imprevedibile e pseudo-randomica, l'unico modo di creare un blocco valido è semplicemente prova ed errore, con l'incremento ripetuto del numero controllando se il nuovo hash corrisponde. Al target corrente di 2<sup>192</sup>, questo significa un media di 2<sup>64</sup> tentativi; in generale, il target è ricalibrato dal network ogni 2016 blocchi in modo che una media di un nuovo blocco è prodotto da qualche nodo nel network ogni dieci minuti. Nella prospettiva di compensare i miners per questo lavoro computazionale, ogni dieci minuti il miner è autorizzato ad includere una transazione donando a se stesso 25 BTC da nulla. In aggiunta, se qualhe transazione ha un valore totale denominale più alto nei suoi inputs che ne suoi outputs, la differenza va al miner come "commissione di transazione". Incidentalmente, questo è pure l'unico meccanismo attraverso cui avviene l'emissione dei BTC; in assoluto lo stato di genesi non contiene alcuna moneta.

Nella prospettiva di una migliore comprensione dello scopo del mining, esaminiamo il caso in cui avvenga un attacco criminoso. Visto che la crittografia implicita nel Bitcoin è conosciuta per essere sicura, l'attaccante colpirà l'unica parte del sistema del Bitcoin che non è protetta direttamente dalla crittografia: l'ordine delle transazioni. La strategia dell'attaccante è semplice:

1. Invio 100 BTC ad un commerciante in cambio di qualche prodotto (preferibilmente un bene digitale consegnabile rapidamente)
2. Attesa per la consegna del prodotto
3. Produzione di un'altra transazione che invia 100 BTC a se stesso
4. Tentativo di convincere il network che la sua transazione a se stesso era quella che è avvenuta per prima.

Una volta avvenuto lo step (1), dopo qualche minuto qualche miner includerà la transazione nel blocco, ad esempio il blocco numero 270000. Dopo circa un'ora, cinque o più blocchi saranno aggiunti alla chain dopo quel blocco, con ognuno di questi blocchi che indirettamente indicano la transazione e quindi la "confermano". A questo punto, il commerciante accetterà il pagamento come finalizzato e consegnerà il prodotto; considerato che stiamo assumendo che questo sia un bene digitale, consegnato in un istante. Adesso, l'attaccante crea un'altra transazione inviando i 100 BTC a se stesso. Se l'attaccante semplicemente rilascia questa in libertà, la transazione non sarà processato; i miners proveranno ad eseguire `APPLY(S,TX)` e prendere nota che `TX` consuma un UTXO che non è più nello stato. Invece in questo modo, l'attaccante crea una "fork" della blockchain, iniziando a minare un'altra versione del blocco 270000 indirizzando il blocco 269999 come una antecedente ma con una nuova transazione che prende il posto di quella vecchia. Poichè i dati del blocco sono differenti, questo richiede il rifacimento della "proof-of-work". Inoltre, la nuova bersione del blocco 270000 dell'attaccante ha un hash differente, così i blocchi originali da 270001 a 270005 non "portano" a quello; quindi, la chain originale e la nuova chain dell'attaccante saranno completamente separate. La regola è che in una fork la blockchain più lunga è considerata essere quella vera, e così i legittimi minatori lavoreranno sulla chain del 270005 mentre l'attaccante da solo sta lavorando sulla chain del 270000. Affinché l'attaccante crei la blockchain più lunga, egli dovrebbe avere più potenza computazionale che il resto del network per ottenere (da quel momento, "51% attacco").

### Merkle Trees

![SPV in bitcoin](https://www.ethereum.org/gh_wiki/spv_bitcoin.png)

_Sinistra: è sufficiente mostrare solo un esiguo numero di nodi in un Merkle tree per dimostrare la prova della validità di un ramo._

_Destra: qualunque tentativo di modificare qualsiasi parte del Merkle tree porterà ad un'incongruenza da qualche parte a monte della chain._

Un'importante funzione della scalabilità del Bitcoin è che nel blocco è memorizzata una struttura di dati multi-livello. L' "hash" di un blocco è in realtà solo l'hash dell'intestazione del blocco, approssimativamente 200-byte di dati che contengono la marca temporale, un numero, hash del precedente blocco e l'hash principale della struttura dei dati chiamata Merkle tree che contiene tutte le transazioni del blocco. Un Merkle tree è un tipo di struttura binaria, composto da un set di nodi con un grande numero di nodi dipendenti alla base della struttura che contengono dati sottostanti, un insieme di nodi intermedi dove ogni nodo è l'hash dei suoi due figli, e alla fine un nodo singolo principale, anch'esso composto dall'hash dei suoi due figli, che rappresenta il "top" della struttura. La finalità del Merkle tree è quello di consentire che i dati in un blocco siano consegnati in maniera frammentaria: un nodo può scaricare solo l'intestazione di un blocco da una sorgente, la piccola parte della struttura di loro interesse da un'altra sorgente, per assicurarsi che tutti i dati siano correnti. Il motivo per cui questo funziona è che gli hash si propagano verso l'alto: se un cattivo utente tenta di cambiare una transazione falsa verso il punto più basso del Merkle tree, questo cambiamento causerà un cambio sul nodo di sopra, e poi un cambio sul nodo sopra quest'ultimo, per cambiare in fine la struttura principal end pertanto l' hash del blocco, causando che il protocollo registri questo come un blocco completamente differente (quasi certamente con un proof of work invalido).

Il protocollo Merkle tree è senza dubbio essenziale per la sostenibilità a lungo termine. Un "nodo completo" nel Bitcoin network, uno che memorizza ed elabora l'interezza di ogni blocco, richiede all'incirca 15 GB di spazio sul disco nel Bitcoin network alla data di Aprile 2014, e sta crescendo di oltre un gigabyte al mese. Allo stato attuale, questo è sostenibile per un computer desktop e non per i telefoni, e più in là con il tempo potranno partecipare solo le aziende e gli appassionati. Un protocollo conosciuto come "controllo semplificato del pagamento" (CSP) permette ad un'altra classe di nodi di esistere, chiamati "nodi leggeri", che scaricano le intestazioni del blocco, verificando la proof of work sulle intestazioni del blocco, e successivamente scaricano solo i  "rami" associati con le transazioni che sono per loro rilevanti. Questo permette ai nodi leggeri di determinare con una forte garanzia di sicurezza quale sia lo status di una qualsiasi transazione Bicoin, ed il loro corrente bilancio, con soltanto il download di una piccolissima parte dell'intera.

### Applicazioni Alternative della Blockchain

L'idea di prendere spunto dalla tecnologia sottostate alla blockchain e di applicarla anche ad altri concetti ha una storia. Nel 2005, Nick Szabo proposte il concetto di "[titoli di proprietà sicuri con l'autorizzazione del proprietario](http://szabo.best.vwh.net/securetitle.html)", un documento che descriveva come "nuovi progressi nella tecnologia di un database replicato" consentiranno ad un sistema basato sulla blockchain di conservare un registro di chi possiede quella terra, creando un quadro elaborato che include concetti come quello di autosufficienza economica, usucapione e la tasse sulla terra Georgiana Tuttavia, sfortunatamente non era disponibile a quel tempo un efficace sistema di database replicato, ed il protocollo non fu mai implementato nella pratica. Ciononostante dopo il 2009 una volta che il consenso decentralizzato del Bitcoin fu sviluppato un numero di applicazioni alternative cominciò rapidamente ad emergere.

* **Namecoin** - creato nel 2010, [Namecoin](https://namecoin.org/) conosciuto come un sistema decentralizzato di database per la registrazione di nomi di dominio. Nei protocolli decentralizzati come Tor, Bitcoin e BitMessage, c'è bisogno di un modo di identificare gli account in modo che le altre persone possono interagire con loro, ma in tutte le soluzioni esistenti l'unico tipo di identificatore disponibile è un hash pseudo casuale come `1LW79wp5ZBqaHW1jL5TCiBCrhQYtHagUWy`. Idealmente, qualcuno potrebbe avere un account con un nome come "george". Tuttavia, il problema è che se una persona può creare un account chiamato "george" poi qualcun altro può utilizzare lo stesso processo per registrare "george" per se stesso così come per impersonificare quell'altra persona. L'unica soluzione è il paradigma first-to-file, dove il primo registrante ha successo ed il secondo fallisce - un problema che si adatta perfettamente al protocollo di consenso del Bitcoin. Namecoin è la più vecchia, e di più successo, implementazione di un sistema di registrazione di dominio che utilizza una tale idea.
* **Monete colorate** - lo scopo delle [monete colorate](https://docs.google.com/a/buterin.com/document/d/1AnkP_cVZTCMLIzw4DvsW6M8Q2JC0lIzrTLuoWu2z1BE/edit) è quello di servire come un protocollo per consentire alle persone di creare le proprie valute digitali - o, nell'importante caso banale di una moneta con una sola unità, tokens digitali, sulla Blockchain del Bitcoin. Nel protocollo delle monete colorate, una persona "emette" una nuova moneta assegnando pubblicamente un colore ad una UTXO specifica del Bitcoin, e il protocollo definisce ricorsivamente il colore dell'altra UTXO al fine che sia dello stesso colore degli inputs di quella transazione da cui deriva (qualche regola speciale si applica nel caso di inputs di colori di monete misti. Questo permette agli utenti di conservare portafogli di monete che contengono solo una UTXO di uno specifico colore e di inviare questa in modo del tutto simile ai Bitcoins, attraverso lo studio della blockchain per determinare il colore di un qualsiasi UTXO che essi hanno ricevuto.
* **Metacoins** - l'idea dietro un metacoin è quello di avere un protocollo che vive in cima Bitcoin, usando le transazioni Bitcoin per conservare le transazioni metacoin ma avendo una differente funzione di transazione, `APPLY'`. Poichè il protoccolo Metacoin non può prevenire che una transazione metacoin invalida cannot prevent invalid metacoin transactions sia visualizzata sulla blockchain del Bitcoin, si aggiunge una regola che se `APPLY'(S,TX)`ritorna come un errore, le impostazioni predefinite del protocollo sono`APPLY'(S,TX) = S`. Questo fornisce un semplice meccanismo per la creazione di un protocollo arbitrario di criptomoneta, potenzialmente con funzioni avanzate che non possono essere implementate all'interno del Bitcoin stesso, ma con un costo di sviluppo molto basso visto che la complessità del mining e del networking sono già gestiti dal protocollo Bitcoin.

Così, in generale, esistono due approcci per la costruzione di un protocollo di consenso: costruire un network indipendente, e costruire un protocollo sul modello di quello del Bitcoin. Il primo approccio è difficile da implementare, anche se ha avuto un buon successo in applicazioni come Namecoin; ogni implementazione individuale necessità una nuova ed indipendente blockchain, così come la costruzione ed il testing di tutta la transizione di stato ed il codice del network. Per di più, si ipotizza che il set di applicazioni per una tecnologia di consenso decentralizzato seguirà la "power law distribution" dove la maggior parte delle applicazioni sarebbe troppo piccola da garantire la loro propria blockchain, e si noti che esistono grandi classi di applicazioni decentralizzate, in particolare le organizzazioni autonome decentralizzate, che necessitano di interagire tra loro.

D'altro canto, l'approccio basato sul Bitcoin, ha il difetto di non avere la funzione di verificazione semplificata del Bitcoin. SPV funziona per il Bitcoin perchè può usare la grandezza della Blockchain come un proxy per la validità; ad un certo punto, una volta che le transazioni precedenti ad un'altra vanno abbastanza indietro  , si può affermare che erano legittimamente parte dello stato. I meta-protocolli basati sulla Blockchain, d'altro canto, non possono forzare questa a non includere le transazioni che non sono valide all'interno del contesto del loro stesso protocollo. Da ciò, un'implementazione di un meta-protocollo SPV altamente sicuro necessiterebbe di analizzare tutte le transazioni fino all'inizio della Blockchain del Bitcoin per determinare quali siano le transazioni valide e quali invalide. Allo stato attuale, tutta la "luce" di implementazioni di meta-protocolli basati sul Bitcoin si basano su un server di fiducia per fornire i dati, probabilmente questo è uno dei migliori risultati possibili soprattutto quando uno degli scopi principali di una Criptovaluta è quello di eliminare la necessità di fiducia.

### Scripting

Attualmente il protocollo del Bitcoin, perfino senza nessuna estensione, facilita una debole versione del concetto di  "smart contracts". UTXO in Bitcoin può essere posseduta non solo come chiave pubblica, ma anche da uno script più complesso espresso in un semplice linguaggio di programmazione  stack-based. In questo paradigma, una spesa di transazione che UTXO deve fornire un dato che soddisfa lo script. Infatti, il meccanismo basico della proprietà della chiave pubblica è implementato con uno script: lo script impiega una firma a curva ellittica  come input, confrontando questa con la transazione e l'indirizzo che possiede la UTXO, e ritorna 1 se la verificazione è andata a buon fine altrimenti 0 in caso contrario. Altri e più complicati scripti, esistono per altri vari casi. Per esempio, si può costruire uno script che richiede firme da due delle tre chiavi private impiegate per validare ("multisig"), un setup utile per conti delle società, che mettono al sicuro i conti correnti e che forniscono ai commercianti funzioni di escrow. Gli scripts possono anche essere usati per pagare premi per la soluzione di problemi computazionali, e si può perfino costruire uno script che dice qualcosa come "questo Bitcoin UTXO è tuo se sei in grado di dare prova di un SPV che tu mi invii una transazione di Dogecoin di questo valore", consentendo essenzialmente un cambio tra cripto-monete.

Tuttavia, il linguaggio di scripting, così come implementato nel Bitcoin, presenta alcune importanti limitazioni:

* **Manca di completezza del linguaggio di Turing**- vale a dire, mentre c'è un grande sottoinsieme di calcolo che il linguaggio di scripting del Bitcoin supporta, esso non supporta quasi tutto. La categoria principale che viene meno è il loop. Questo viene fatto per evitare cicli infiniti durante la verifica delle transazioni; teoricamente questo è un ostacolo sormontabile per il programmatori di script, visto che qualsiasi loop può essere simulato semplicemente ripetendo il codice sottostante tante volte con un'istruzione "if", ma questo porta a scripts che sono inefficienti dal punto di vista dello spazio. Per esempio, con l'implementazione di un algoritmo alternativo di firma a curva ellittica necessiterebbe 256 rounds ripetuti di moltiplicazioni tutte individualmente incluse nel codice.
* **Cecità-del-valore** - non c'è un modo per un UTXO di fornire un controllo a grana fine sull'ammontare che può essere ritirato. Per esempio, un buon caso di studio può consistere in un contratto oracolo con un contratto sottostante, dove A e B mettere in valore di $ 1000 di BTC e dopo 30 giorni lo script invia il controvalore di $1000 in BTC ad A ed il resto a B. Questo necessiterebbe di un oracolo per determinare il valore di 1 BTC in USD, ma anche allora in presenza di un incremento esponenziale in termini di fiducia ed infrastruttura necessaria per una soluzione completamente centralizzata che è disponibile ora. Tuttavia, poichè UTXO sono tutte-o-nessuna, l'unico modo per raggiungere questo risultato è attraverso l'inefficiente hack di avere molte UTXO di varie denominazioni (es. una UTXO di 2k per ogni k fino a 30) e avendo O scelta dove UTXO spedisce ad A e quindi a B.
* **mancanza di stato** - UTXO può essere sia speso che non spesp; non c'è un'opportunità per contratti o scripts multi-stage wche mantengono qualche altro stato interno oltre questo. Questo rende difficile creare contratti di opzioni multi-stage, exchange decentralizzato che offre two-stage protocolli crittografici dedicati (necessarie per sicuri premi computazionali). Questo inoltre significa che UTXO può essere soltanto usata per costruire, contratti unici e un non più complessi "stateful" contratti come le organizzazioni decentralizzate, e creare meta-protocolli difficili da implementare. Lo stato binario combinato con la cecità-del-valore significa anche che un'altra importante applicazione, limiti di prelievo, è impossibile.
* **cecità-della-Blockchain** - UTXO è cieca alla blockchain come il nonce dell'hash precedente. Questo pregiudica applicazioni nel gioco d'azzardo, e altre molte categorie, privando il linguaggio di scripting di una fonte potenzialmente preziosa di casualità.

Quindi, esistono tre approcci per costruire applicazioni avanzate sull'apice della criptomoneta: costruire una nuova blockchain, usando scripting sull'apice del Bitcoin, e costruire un meta-protocollo sull'apice del Bitcoin. Costruire una nuova Blockchain permette una illimitata libertà nel costruire un set di funzionalità, ma al costo del tempo di sviluppo, lo sforzo di bootstrapping e sicurezza. Usare lo scripting è semplice da implementare e standardizzare, ma è molto limitato nelle sue capacità, e i meta-protocolli, sono facili, ma soffrono di difetti di scalabilità. Con Ethereum, noi intendiamo costruire un framework alternativo che fornisce guadagni ancora maggiori in termini di facilità di sviluppo e ancora più forti proprietà di leggerezza per i client, ed allo stesso tempo permettendo alle applicazioni di condividere un ambiente economico e la sicurezza della blockchain.

## Ethereum

Lo scopo di Ethereum è quello di creare un protocollo alternativo per la costruzione di applicazioni decentralizzate, fornendo un set differente di scambi che noi crediamo saranno molto utili per una larga classe di applicazioni decentralizzate, con particolare enfasi sulle situazioni dove sono importanti un rapido tempo di sviluppo, sicurezza per applicazioni raramente utilizzate, e l'abilità di differenti applicazioni di interagire molto efficacemente. Ethereum permette questo costruendo quello che è essenzialmente il definitivo protocollo astratto fondante: una blockchain con un linguaggio di programmazione Turing-complete costruito al suo interno, che permette ad ognuno di scrivere smart contracts e applicazioni decentralizzate dove creare le proprie regole arbitrarie per la proprietà, i formati delle transazioni e le funzioni di transizione di stato. Una scarna versione di Namecoin può essere scritta in due linee di codice, e gli altri protocolli come le criptomonete e i sistemi di reputazione possono essere costruiti al di sotto delle venti linee. Gli smart contracts, i "boxes" crittografici che contengono valore possono essere sbloccati solo se si verificano certe condizioni, possono essere anche costruiti sull'apice di della pittaforma, con degli strumenti molto più efficaci di quelli offerti dallo scripting del Bitcioin grazie agli strumenti offerti dalla completezza del linguaggio di Turing, consapevolezza del valore, consapevolezza della blockchain e dello stato.

### Ethereum Accounts

In Ethereum, lo stato è costituito da oggetti chiamati "accounts", in cui ogni account ha un indirizzo di 20-byte e le transizioni di stato sono trasferimenti diretti del valore e dell'informazione tra gli accounts. Un account Ethereum account contiene quattro campi:

* Il **nonce**, un contatore utilizzato per assicurarsi che ogni transazione può essere elaborata una sola volta
* Il conto corrente dell'account **bilancio ether**
* Il **contract code** dell'account, se presente
* Lo **storage** dell'account (vuoto da default)

"Ether" è l'interno e principale crypto-carburante di Ethereum, e viene usato per pagare le commissioni di transazione. In generale, esistono due tipi di account: **accounts posseduti dall'esterno**, controllati da chiavi privati, e **gli accounts contratto**, controllati dal loro codice di contratto. Un account posseduto dall'esterno non ha codice, e si possono mandare messaggi esterni dall'account posseduto esternamente creando e firmando una transazione; in un account contratto, ogni volta che questo riceve un messaggio il suo codice si attiva, permettendo a questo di leggere e scrivere verso uno storage interno e spedire altri messaggi o creare contratti a sua volta.

Si noti che i "contratti" in Ethereum non dovrebbero essere visti come qualcosa che dovrebbe essere "riempita" o "complilata con"; piuttosto, essi sono più come "agenti autonomi" che vivono all'interno dell'ambiente di esecuzione di Ethereum, che eseguono sempre uno pezzo specifico di codice che viene "colpito" da un messaggio o da una transazione, e avendo il controllo diretto sul proprio conto di ether e sulla propria chiave/valore di store al fine di tenere traccia delle variabili persistenti.

### Messaggi e Transazioni

Il termine "transazione" è utilizzato in Ethereum per riferirsi al pacchetto di dati firmati che contengono un messaggio da inviare da un account posseduto dall'esterno. Le Transazioni contengono:

* Il destinatario del messaggio
* Una firma che identifica il mittente
* L'ammontare di ether da trasferire al destinatario 
* Un campo dati opzionale
* Un valore`STARTGAS`, che rappresenta il massimo numero di steps computazionali che l'esecuzione della transazione può impiegare
* Un valore`GASPRICE`, che rappresenta la commissione che il mittente paga per lo step computazionale

i primi tre sono campi standard previsti in qualsiasi criptovaluta. Il campo dati non ha nessuna funzione da default, ma la virtual machine ha un codice operativo con cui un contratto può accedere ai dati; come caso di esempio, se un contratto sta funzionando come un servizio di registrazione di dominio basato sulla blockchain, allora può desiderare di interpretare i dati che vengono passati ad esso come contenenti due "campi ", il primo campo essendo un dominio da registrare ed il secondo essendo l'indirizzo IP da registrare. Il contratto dovrebbe leggere questi valori dai dati del messaggi e collocarli appropriatamente nello storage.

I campi `STARTGAS` e`GASPRICE` sono cruciali per il modello di servizio anti-denial di Ethereum. Al fine di prevenire loops, accidentali o ostili, infiniti o altro spreco computazionale di codice, ad ogni transazione è richiesto di impostare un limite per l'uso di steps computazionali di codice di esecuzione. L'unità fondamentale di computazione è il "gas"; di solito, uno step computazionale costa 1 gas, ma alcune operazioni richiedono più unità di gas perchè esse sono computazionalmente più complesse, o richiedono un numero più elevato di dati che devono essere conservati come una parte dello stato. C'è anche una commissione di gas per ogni byte nei dati della transazione. L'obiettivo del sistema di commissione è quello di richiedere ad un aggressore di pagare proporzionalmente per ogni risorsa che essi consumano, includendo la computazione, larghezza di banda, e storage; quindi, qualsiasi transazione che comporta che il network consumi una quantità più grande di qualsiasi di queste risorse deve avere una commissione gas grosso modo proporzionale alla grandezza dell'incremento.

### Messaggi

I contratti hanno l'abilità di inviare "messaggi" ad altri contratti. I messaggi sono oggetti virtuali che non vengono mai serializzati ed esistono solo nell'ambiente di esecuzione di Ethereum. Un messaggio contiene:

* Il mittente del messaggio (implicito)
* Il destinatario del messaggio
* L'ammontare di ether da inviare attraverso il messaggio
* Un campo dati opzionale
* Un valore `STARTGAS` 

Essenzialmente, un messaggio è come una transazione, eccetto che esso viene prodotto da un contratto e non da un attore esterno. Un messaggio è prodotto quando un contratto che sta eseguendo il codice fa effettua una operazione `CALL`, che produce ed esegue un messaggio. Come una transazione, un messaggio comporta che l'account del destinario esegue il proprio codice. Quindi, i contratti possono avere relazioni con altri contratti esattamente alla stesso modo che avviene con degli attori esterni.

Si noti che la quantità di gas che serve ad una transazione o ad un contratto si applica alla totalità del gas consumato da quella transazione e da tutte le sub-esecuzioni. Per esempio, se un attore esterno A trasmette una transazione a B con 1000 gas, e B consuma 600 gas prima di inviare il messaggio a C, e l'esecuzione interna di C consuma 300 gas prima di ritornare, poi B può spendere altri 100 gas prima di rimanere a corto di gas.

### La Funzione di Transizione di Stato di Ethereum

![ethertransition.png](http://vitalik.ca/files/ethertransition.png?1)

La funzione di transizione di stato di Ethereum, `APPLY(S,TX) -> S'` può essere definita come segue:

1. Controlla se la transazione è ben impostata (ie. ha il giusto numero di valori), la firma è valida, e il nonce corrispode a quello dell'account del mittente. In caso contrario, si ha un errore.
2. Calcola la commissione di transazione come `STARTGAS * GASPRICE`, e determina l'indirizzo del mittente dalla firma. Sottrae la commissione dal bilancio dell'account del mittente e incrementa il nonce del mittente. Se non c'è un bilancio sufficiente da spendere, si ha un errore.
3. Inizializza `GAS = STARTGAS`, e toglie una certa quantità di gas per byte per pagare i byte nella transazione.
4. Trasferisce il valore della transazione dall'account del mittente all'account del destinatario. Se l'account del destrinario non esiste ancora, lo crea. Se l'account del ricevente è un contratto, esegue il codice del contratto sia per il completamento o fino a quando l'esecuzione finisce il gas.
5. Se il valore di trasferimento fallisce perché il mittente non ha abbastanza soldi, il il code di esecuzione finisce il gass, ripristina tutti i cambiamenti di stato, tranne il pagamento delle commissione , e aggiunge le commissioni sul conto del minatore .
6. Altrimenti, risarcisce al mittente le commissioni per il gas rimanente, ed invia le commissioni pagate per il gas e consumate al miner.

Per esempio, si supponga che il codice del contratto è:

    se !self.storage[calldataload(0)]:
        self.storage[calldataload(0)] = calldataload(32)

Si noti che in realtà il codice del contratto è scritto in un codice EVM di basso livello; questo esempio è scritto in Serpent, che, per essere chiari, è uno dei nostri linguaggi di alto livello, può essere compilato fino al codice EVM. Si supponga che lo storage del contratto sia inizialmente vuoto, e la transazione è inviata con un valore di 10 ether, 2000 gas, al prezzo di 0.001 ether gas, e 64 bytes di dati, con bytes 0-31 che rappresentano il numero `2` e i bytes 32-63 che rappresentano la stringa `CHARLIE`. Il processo per la funzione di transizione di stato è in questo caso come segue:

1. Controlla che la transizione è valida è ben impostata.
2. Controlla che il mittente abbia almeno 2000 * 0.001 = 2 ether. If it is, quindi sottrae 2 ether dall'account del mittente.
3. Inizializza gas = 2000; assumendo che la transazione è lunga 170 bytes e la commissione di byte è 5, sottrae 850 così che c'è 1150 gas che rimane.
3. Sottrae altri 10 ether dall'account del mittente, e li aggiunge all'account del contratto.
4. Esegue il codice. In questo caso, questo è semplice: esso controlla che lo storage del contratto all'indice `2` sia usato, prende nota che non lo è, e così imposta lo storage all' index `2` al valore `CHARLIE`. Si supponga che questo impieghi 187 gas, così l'ammontare rimante di gasi sia 1150 - 187 = 963
5. Aggiunge 963 * 0.001 = 0.963 di nuovo sul conto del mittente, e ritorna lo stato risultante.

Se non ci fosse alcun contratto alla fine di ricezione della transazione, quindi il totale della commissione di transazione sarebbe semplicemente uguale al `GASPRICE` provvisto moltiplicato per la lunghezza della transazione in bytes, ed i dati inviati per mezzo della transazione sarebbero irrilevanti.

Si noti che i messaggi lavorano in maniera equivalente alle transazioni in termini di ripristino: se un messaggio in esecuzione finisce il gas, quindi l'esecuzione del messaggio, e tutte le altre esecuzioni innescate da questa esecuzione, tornano indietro, ma le esecuzioni precedenti non hanno bisogno di farlo. Questo significa che è "sicuro" per un contratto di richiamare un altro contratto, se A chiama B con G di gas poi l'esecuzione di A è garantita per perdere al massimo G. Alla fine, si noti che c'è un codice operativo, `CREATE`, che crea un contratto; il proprio meccanismo di esecuzione è generalmente simile a `CALL`, con l'eccezione che questo output di esecuzione determina il codice di un contratto recentemente creato.

### Esecuzione del Codice

Il codice nel contratti Ethereum è scritto in un linguaggio di basso livello, linguaggio bytecode a cascata, denominato "codice virtual machine Ethereum" o"codice EVM". Il codice consiste in una serie di bytes, dove ogni byte rappresenta un'operazione. In generale, l'esecuzione del codice è un loop infinito che consiste nel realizzare ripetutamente l'operazione al contatore del programma attuale (che inizia con zero)  e incrementando il contatore del programma di uno, fino a che si ottiene la fine del codice od un errore o `STOP` o è rilevato l'istruzione `RETURN`. Le operazioni hanno accesso a tre tipi di spazio nel quale registrare i dati:

* Lo **stack**, un last-in-first-out contenitore nel quale i valori possono essere spinti e spuntati
* **Memoria**, un array di byte espandibile all'infinito
* Il lungo-termine del contratto **storage**, una chiave/valore di store. A differenza dello stack e della memoria, che si resettano dopo la fine del calcolo, lo storage persiste per un lungo periodo.

Il codice può anche accedere al valore, mittente e dati del messaggio in arrivo, così come ai dati in testata al blocco, e il codice può anche ritornare come un'array di dati come output.

Il modello di esecuzione formale del codice EVM è sorprendentemente semplice. Mentre la virtual machine di Ethereum funziona, tutto il suo stato computazionale può essere definito dall'insieme di dati `(stato_del_blocco, transazione, messaggio, codice, memoria, stack, pc, gas)`, dove `stato-del_blocco` è lo stato globale che contiene tutti gli accounts e include i bilanci e lo storage. All'inizio di ogni turno di esecuzione, l'istruzione corrente viene trovata prendendo il `pc`th byte del `codice` (o 0 se `pc >= len(codice)`), e ogni istruzione ha la sua propria definizione in termini  di come interagisce con l'insieme di dati. Per esempio, `ADD` espelle due oggetti fuori dallo stack e spinge la loro somma, riduce `gas` di 1 e incrementa `pc` by 1, e `SSTORE` espelle i due oggetti all'apice fuori dallo stack ed inserisce il secondo oggetto nello storage del contratto all'indice specificato dal primo oggetto. Sebbene ci sono molti modi di ottimizzare l'esecuzione della virtual machine di Ethereum attraverso una pronta compilazione, un'implementazione basica di Ethereum can in poche centinaia di righe di codice.

### Blockchain e Mining

![apply_block_diagram.png](http://vitalik.ca/files/apply_block_diagram.png)

La blockchain di Ethereum è in molti modi simile a quella del Bitcoin, seppur con qualche differenza. La differenza princiale tra Ethereum e Bitcoin con riguardo all'architettura della blockchain, è che, contrariamente al Bitcoin, i blocchi di Ethereum contengono una copia sia  dell'elenco delle transazioni sia lo stato più recente. A parte questo, gli altri due valori, il numero di blocco e la difficoltà, vengono memorizzati nel blocco. L'algoritmo di validazione del blocco alla base in Ethereum funziona in questo modo:

1. Controlla se il se il precedente blocco di riferimento esiste ed è valido.
2. Controlla se la marca temporale del blocco è più grande di quella del blocco di riferimento precedente ed inferiore di 15 minuti nel futuro.
3. Controlla che il numero del blocco, difficoltà, l'origine della transazione, la transazione derivata ed il limite del gas ( vari e specifici concetti di basso-livello di Ethereum) sono validi.
4. Controlla se il proof of work sul blocco sia valido.
5. Sia `S[0]` lo stato alla fine del blocco precedente.
6. Sia`TX` la lista delle transazioni del blocco, con `n` transazioni. Per tutti in `0...n-1`, set `S[i+1] = APPLY(S[i],TX[i])`. Se qualsiasi applicazioni dà errore, o se il gas totale è consumato nel blocco fino a che questo punto eccede il `GASLIMIT`, anche questo, dà errore. 
7. Sia `S_FINAL` `S[n]`, ma aggiungendo la ricompensa per il blocco pagata al miner.
8. Controlla che lo stato originario del Merkle tree `S_FINAL` sia uguale allo stato finale originario fornito nell'intestazione del blocco. In tal caso, il blocco è valido; in caso contrario, quest'ultimo non è valido.

L'approccio può sembrare molto inefficiente a prima vista, perché questo necessita di registrare l'intero stato di ogni blocco, ma in realtà l'efficienza dovrebbe essere comparabile a quella del Bitcoin. La ragione sta nel fatto che lo stato è registrato in una struttura ad albero, e dopo ogni blocco una piccola parte dell'albero necessita di essere cambiata. Quindi, in generale, tra due blocchi adiacenti la grande maggioranza dell'albero dovrebbe essere la stessa, e quindi i dati possono essere registrati una sola volta e consultati due volte usando i puntatori (ad es. gli hash degli alberi inferiori). Un tipo speciale di albero conosciuto come "Patricia tree" viene usato per raggiungere questo risultato, includendo una modifica del concetto del Merkle tree, che permette ai nodi di essere inseriti e cancellati, e non solo cambiati, in maniera efficiente. Per di più, poiché tutta l'informazione sullo stato è una parte dell'ultimo blocco, non c'è bisogno di registrare tutta la storia della blockchain - una strategia che, se applicata al Bitcoin, può consentire un risparmio di spazio di 5-20x.

Un quesito comune che viene posto è "dove" il codice del contratto viene eseguito, in termini di hardware fisico. Questa è una risposta semplice: il processo di esecuzione del codice del contratto è una parte della definizione dello funzione di transizione di stato, che è una parte dell'algoritmo di validazione del blocco, così che se una transazione è aggiunta al blocco `B` l'esecuzione del codice generata da questa transazione sarà eseguita da tutti i nodi, nel presente e nel futuro, scaricando e validando il blocco `B`. 

## Applicazioni

In generale, ci sono tre tipi di applicazioni costruite su Ethereum. La prima categoria sono le applicazioni finanziarie, che forniscono agli utenti molteplici e più potenti modi di gestire ed usufruire i contratti attraverso l'uso dei proprio soldi. Questo include le sub-monete, i derivati finanziari, ci contratti di hedging, i libretti di risparmio, i testamenti, e per ultimo perfino qualche genere di contratto collettivo di lavoro. 
La seconda categoria consiste nelle applicazioni quasi finanziarie, dove è coinvolto il denaro, ma c'è anche un lato non monetario importante per quello viene fatto; un esempio perfetto è l'auto-assegnazione di premi per le soluzioni di problemi computazionali. Infine, ci sono applicazioni come il voto online e il governo decentralizzato che non sono assolutamente finanziarie.

### Sistema dei Tokens

Il sistema dei tokens basato sulla blockchain ha molte applicazioni che vanno dalle sub-monete che rappresentano assets come USD o gold di azioni di società, tokens individuali che rappresentano smart property, che assicurano coupons non falsificabili, e perfino sistemi di token  senza nessun legame con un valore convenzionale, utilizzati come sistemi di punti di incentivazione. I sistemi di Token sono sorprendentemente semplici da implementare in Ethereum. Il punto chiave è che tutte queste monete, o sistema di token, sono fondamentalmente un database che funzione con una operazione: sottrae X unità da A e conferisce X unità a B, con la condizione che (i) X aveva almeno X unità prima che la transazione e la (2) tansazione sia approvata da A. Tutto quello che serve per implementare un sistema di tokens consiste nell'implementare questa logica in un contratto .

Il codice basico per implementare un sistema di token attraverso Serpent è come segue:

    def send(to, value):
        if self.storage[msg.sender] >= value:
            self.storage[msg.sender] = self.storage[msg.sender] - value
            self.storage[to] = self.storage[to] + value

Questa è sostanzialmente un'implementazione letterale della funzione di stato del "sistema bancario" descritta in precedenza in questo documento. Poche altre linee di codice devono essere aggiunte per fornire lo step iniziale per la distribuzione delle unità di moneta nel primo luogo ed in altri casi limite, ed idealmente una funzione sarebbe aggiunta per lasciare agli altri contratti di domandare il saldo di un indirizzo. Ma questo è tutto ciò di cui c'è bisogno. Teoricamente, i sistemi di token basati su Ethereum, che fungono da sub-monete, possono potenzialmente includere un'altra importante caratteristica basata sulla mancanza di meta-monete sulla chain del Bitcoin: l'abilità di pagare le commissioni di transazione direttamente in quella moneta. Il modo in cui questo potrebbe essere implementato consiste che quel contratto manterrebbe un saldo di ether con cui risarcire gli ether usati per pagare le commissioni al mittente, e ricaricherebbe questo saldo raccogliendo le unità di moneta interne che esso impiega in commissioni e rivendendo queste in una costante vendita all'asta. Gli utenti avrebbero bisogno di "attivare" i loro accounts con ether, ma una volta che ether è là esso sarebbe riusabile perché il contratto lo risarcirebbe ogni volta.